## Ceasar Cipher

To create a Ceasar Cipher, there are three different data pieces included:  *the input string*, *the input shift value*, and *the output string*. At a high level, I need to manipulate the input string based on the number that is input as the shift value and return the output string. So,  
* The input string  
I can ask for input and use the `gets.chomp` method to store it as a string. I then need to convert this string to a new string, using the information obtained from the input shift value.  
* The input shift value  
I can ask for an input shift integer and use the `gets.chomp.to_i` method to store it as a variable. I will then use this to manipulate the input string and output the new string.  
* The output string  
This is the most difficult portion of the problem: converting the input string to the output string. I definitely need to use arrays and iteration, so I can perform the same conversion to each character that was input. I am going to start with 2 arrays, one with the normal alphabet with each letter as an element, and another array that will be filled with each character of the input string. I can then iterate through each character of the input string, match it with the corresponding index location in the alphabet array, subtract the input shift value (which is the same as moving to the left in the alphabet), and then return a new letter from the alphabet based on the new index value. I can store this new combination of ciphered letters in a final array, which I can then join together and display to the user as a string. I see potential issues for spaces and numbers that may be entered into the input string, but won't have a corresponding match in the alphabet array. I need to figure out a solution to address those non-alphabet characters. I also see a potential issue with letters near the beginning of the alphabet where subtraction may result in negative numbers; however, based on my understanding of arrays in Ruby, Ruby should start counting backward from the last element of the array with a negative index value, so the method should still function correctly.  

### Post-Build Notes and Additional Comments
I used an *if/else statement* to address the issue of spaces and non-alphabet characters included in the input string. If the character is included in the alphabet array of characters, then it is changed, but if it is not included, then it is just passed through and added to the output array with no changes. I plan to experiment with this program further and see if I can also manipulate integers by the same input shift value as the alphabet characters. I would also like to experiment with including an empty space string in the alphabet array, maybe at index location 0, so both characters and spaces would change with the cipher.

## Checker Board  
To create a checker board, there is only one input data value that can change, the *size*. This size will determine how large the checker board is. In addition to the size, the other data piece involved is the sequence of "X"s and " "s that will compose the checker board. Because you cannot have two X's on top of each other, 2 sequences will be needed that will alternate back and forth for each row. Thus, I will need to nest an iteration sequence inside of an iteration sequence. The outer sequence will iterate the entered *size* times for each row, and then the inner sequence will iterate the "X"s and " "s for the entered *size* times. The if/else statements will be needed to begin the sequence with either an "X" or " ", depending on whether it's an even or odd row. In addition, an if/else statement will be needed to determine whether an "X" or " " are added to the string, depending on whether it's an even or odd number in the sequence. That should result in the desired checker board pattern.

### Post-Build Notes and Additional Comments
The nested if/else statements worked; however, I need to run the row method *size + 1* times to obtain the correct number of rows. I am not sure why this is, but I'm guessing it might have something to do with the new line command that I had to enter after the last character of each row to prepare for the next row. I only have to run the individual character methods a *size* number of times to obtain the correct number of characters, so this is baffling. The new line command is the only significant difference between the two, so I believe it must play a factor.
